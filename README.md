# RaspberryPi-Zero-BareMetal

This example of bare metal programming for the Raspberry Pi Zero.  In this case I am using a Pi Zero W.  The ultimate goal is to develop a system to make a drone follow a predetermined flight path.  I started out by perusing David Welch's bare metal examples (https://github.com/dwelch67/raspberrypi-zero).

04/22/2021:  First installment, lot's left to do.  Here is what I have currently.  The Pi will boot and can display things using a simple serial port to USB adapter.  There are plenty of examples on how to hook up the serial port, I won't go into that here.  Suffice it to say this is critical.  Second, I am currently using David Welch's boot loader with a slight modification.  I was having reliability problems with the terminal emulation program (I am using a Windows environment) TeraTerm.  I modified the bootloader to download from the serial port into a buffer and also check for a 'g' to be sent.  Once the bootloader sees a 'g' it begins to unpack the S-records from the buffer into memory and then jumps to the beginning of the downloaded code.  Also, I should mention I am using the GNU ARM Embedded Toolchain, currently the "10 2020-q4-major" version.  My current system setup has the Pi Zero with the serial port connected along with the I2C bus connected to a Bosch BME 280 temperature, pressure and humidity sensor.  On the BME 280 I have the CSB pin pulled up and the SD0 pin grounded (giving a an I2C slave address of 0x76).  The intention of this development project is to create a board support package that supports the Broadcom 2835 ARM, floating point coprocessor and peripherals.  So far there is support for floating point operations, interrupts, the mini-UART, basic GPIO pin support, and the I2C and SPI busses.  The SPI support has been tested with the BME 280 but I am intending to stick with the I2C.

Along with using the bootloader to test I have also tested the ability to boot directly into the code.

Next up will be refining the use of the BME 280, since it currently isn't very stable, however, I may find I have to abandon the BME 280, we shall see.  Also I will be implementing support for an MPU 6050 and then seeing if we can move the system around and track the movement along a predetermined path, providing feedback when the system goes off the desired path.